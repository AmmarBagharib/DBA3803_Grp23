---
title: "Group 23"
date: "9/11/2022"
output: html_document
---

```{r}
library(plyr)
library(dplyr)
library(stringr)
library(readxl)
library(glmnet)
library(ggplot2)
library(lubridate)
```

```{r}
data <- na.omit(read.csv('NEW_48_Industry_Portfolios_Daily.csv', skip = 9)) #25292
N_industry = c(2,3,4,5,6,7) # sample(c(2:49), 6) # Sample out 6 industry
columns <- colnames(data)[c(1, N_industry)] # Take out 6 columns out of the chosen industry
w_ew = matrix(1/length(N_industry), nrow = length(N_industry), ncol = 1) # Get the equally weighted matrix
N = rbind(diag(length(N_industry) - 1), -1) # N as identified in the mathematical equation

# Number of rows to collect = 63 to estimate the covariance matrix E
end_row <- which(data$X == '20211231') # To identify the row that correspond to the date
start_row <- end_row - 63 + 1 # To get the starting data to collect for the 63 observations
data1 <- data[columns][start_row:end_row,] # 63 datas
demean_data <- scale(data1[-1], scale = F) # Scale the data such that the data is demean where the sample mean of each asset return is 0
y = demean_data %*% w_ew # Matrix multiplication of Rwew
X = demean_data %*% N # Matrix multiplication of RN
lasso = cv.glmnet(X,y, alpha = 1, standardise = F, intercept = F) # Train the model using Lasso and does 10-fold cross validation and produce the best lambda 
ridge = cv.glmnet(X,y, alpha = 0, standardise = F, intercept = F) # Train the model using Ridge and does 10-fold cross validation and produce the best lambda 
predict(lasso, s = lasso$lambda.1se)
plot(lasso, sign.lambda = -1)
plot(ridge, sign.lambda = -1)
```

# Question 1 & 2

```{r}
getcvplot = function(Nindustry){
    data <- na.omit(read.csv('NEW_48_Industry_Portfolios_Daily.csv', skip = 9)) #25292
    N_industry = sample(c(2:49), Nindustry) 
    columns <- colnames(data)[c(1, N_industry)]
    # print(columns)
    w_ew = matrix(1/length(N_industry), nrow = length(N_industry), ncol = 1) 
    N = rbind(diag(length(N_industry) - 1), -1)
    # Number of rows to collect = 63 to estimate the covariance matrix E
    end_row <- which(data$X == '20211231')
    start_row <- end_row - 63 + 1
    data1 <- data[columns][start_row:end_row,]
    demean_data <- scale(data1[columns[2:length(columns)]], scale = F)
    y = demean_data %*% w_ew
    X = demean_data %*% N
    lasso = cv.glmnet(X,y, alpha = 1, standardise = F, intercept = F)
    ridge = cv.glmnet(X,y, alpha = 0)
    par(mfrow = c(1,2))
    plot(lasso, sign.lambda = -1)
    plot(ridge, sign.lambda = -1, xlim = c(-1,1))
}
```





# Question 4
```{r}
# EW Plot
# data <- na.omit(read.csv('NEW_48_Industry_Portfolios_Daily.csv', skip = 9)) #25292
data <- read.csv('NEW_48_Industry_Portfolios_Daily.csv', skip = 9, na.strings = '-99.99') #25292
data <- data[which(data$X == '19880412'):which(data$X == '20220630'),] # 20160104 till date
data1 <- data %>% mutate(Total = rowSums(data[-1]/48, na.rm = T), Total = Total/100) %>% select(X, Total)
rownames(data1) <- NULL

data_yest <- data1[1, ]
data_tdy <- data1[1 + 1, ]

x <- data1[1, ]
returns <- data.frame('Dates' = x$X, 'Cummulative_Returns' = 1 + (1 * x$Total))
for (i in seq(2,nrow(data1) - 1)){
    data_yest <- returns[i - 1, ]
    data_tdy <- data1[i, ]
    returns <- rbind(returns, c('Dates' = data_tdy$X, 'Cummulative_Returns' = as.numeric(data_yest$Cummulative_Returns) + as.numeric(data_yest$Cummulative_Returns)*data_tdy$Total))
}
returns$Dates <- ymd(returns$Dates)
returns$Cummulative_Returns <- as.numeric(returns$Cummulative_Returns)
ggplot(returns) + geom_line(aes(Dates, Cummulative_Returns))
```
```{r}
# Lasso and Ridge Return
data <- read.csv('NEW_48_Industry_Portfolios_Daily.csv', skip = 9, na.strings = '-99.99') #25292
data <- data[which(data$X == '19880412'):which(data$X == '20220630'),] # 20160104 till date
rownames(data) <- NULL
N_industry <- length(names(data)) - 1

w_ew <- matrix(1/N_industry , nrow = N_industry)
R <- scale(data[-1], center = T, scale = F)
N <- rbind(diag(N_industry - 1), -1)
y = R %*% w_ew
X = R %*% N
lasso <- cv.glmnet(X, y, alpha = 1, standardise = F, intercept = F)
ridge <- cv.glmnet(X, y, alpha = 0, standardise = F, intercept = F)

# Computation of Lasso Return
beta_lasso <- matrix(coef(lasso, )[-1])
w_lasso <- w_ew - N %*% beta_lasso
data1 <- data %>% mutate(Total = rowSums(as.numeric(t(w_lasso)) * data[-1]), Total = Total/100) %>% select(X, Total)
x <- data1[1, ]
returns1 <- data.frame('Dates' = x$X, 'Cummulative_Returns' = 1 + (1 * x$Total))
for (i in seq(2,nrow(data1) - 1)){
    data_yest <<- returns1[i - 1, ]
    data_tdy <<- data1[i, ]
    returns1 <- rbind(returns1, c('Dates' = data_tdy$X, 'Cummulative_Returns' = as.numeric(data_yest$Cummulative_Returns) + as.numeric(data_yest$Cummulative_Returns)*data_tdy$Total))
} 
returns1$Dates <- ymd(returns1$Dates)
returns1$Cummulative_Returns <- as.numeric(returns1$Cummulative_Returns)

# returns is equally weighted
# returns1 is lasso
ggplot() + geom_line(data = returns1, aes(Dates, Cummulative_Returns, colour = 'Lasso')) + geom_line(data = returns, aes(Dates, Cummulative_Returns, colour = 'Equally_Weighted')) + scale_colour_manual("", breaks = c("Equally_Weighted", "Lasso"), values = c("red", "black"))
```



















#loading the File
```{r}
data <- na.omit(read.csv('NEW_48_Industry_Portfolios_Daily.csv', skip = 9, na.strings = "-99.99"))
colnames(data)[1] <- 'Dates' #rename dates column
```

#Cummulative Return Code
```{r}
N_industry <- c(2:49)
columns <- colnames(data)[c(1, N_industry)]
w_ew <- matrix(1/length(N_industry), nrow = length(N_industry), ncol = 1) # Get the equally weighted matrix
# N identity matrix as identified in the mathematical equation
N <- rbind(diag(length(N_industry) - 1), matrix(-1, ncol = length(N_industry) - 1)) 
# Choosing start and end dates
end_row <- which(data$Dates == "20220103") 
start_row <- which(data$Dates =="20120103")
#convert dates column into date format
data <- data %>% mutate(Dates = ymd(as.character(Dates)))
#slice data based on start and end dates
data1 <- data[columns][start_row:end_row,]
# Scale the data such that the data is demean where the sample mean of each asset return is 0
# by specifying center=T and scale=F, we aim to subtract the mean from each individual return but NOT dividing by the standard deviation.
demean <- scale(data1[, c(2:length(columns))], center=T, scale = F) 
y <- demean %*% w_ew # Matrix multiplication of RWew
x <- demean %*% N # Matrix multiplication of RN
lasso <- cv.glmnet(x, y, alpha = 1, standardise = F, intercept = F) 
ridge <- cv.glmnet(x, y, alpha = 0, standardise = F, intercept = F) 
```

#deriving beta and weights
```{r}
#applying weights of coefficients.
lasso_beta <- t(matrix(coef(lasso, s = "lambda.min")))[-1] #or should we use lambda.1se?
ridge_beta <- t(matrix(coef(ridge, s = "lambda.min")))[-1]
lasso_weights <- w_ew - N %*% lasso_beta
ridge_weights <- w_ew - N %*% ridge_beta
```

#function to extract daily returns
```{r}
daily_returns <- function(weights, df){
  # weights = lasso_weights
  # df = data1
  #function to return vector of daily returns
  #initialise vector of returns
  returns <- c()
  #for loop to generate returns from model
  for (i in 1:nrow(df)){
    #sumproduct weights and individual returns
    day_return <- crossprod(as.vector(weights), as.numeric(as.vector(df[i, 2:ncol(df)])))
    #append weighted return
    returns <- append(returns, day_return)
  }
  return (returns)
}
```

#daily returns for lasso, ridge, ew
```{r}
lasso_daily_returns <- daily_returns(lasso_weights, data1)
ridge_daily_returns <- daily_returns(ridge_weights, data1)
ew_daily_returns <- daily_returns(w_ew, data1)
#initialise vector of cumulative returns with initial investment of $10
cum_lasso_returns_vector <- c(10 * (1 + lasso_daily_returns[1] / 100))
cum_ridge_returns_vector <- c(10 * (1 + ridge_daily_returns[1] / 100))
cum_ew_returns_vector <- c(10 * (1 + ew_daily_returns[1] / 100))
```

#function to return vector of cumulative returns
```{r}
cum_return <- function(df, return_vector, cum_return_vector){
  #function returns cum return for initial investment of $10
  #inputs 'return vector' is the vector of daily returns
  # df = data1
  # return_vector = lasso_daily_returns
  # cum_return_vector = cum_lasso_returns_vector
  for (i in 2:nrow(df)){
    #i = 1
    # return of that day
    return <- 1 + return_vector[i] / 100
    # new cum return based on previous day daily return
    new_cum_r <- cum_return_vector[i - 1] * return
    # append new cum return
    cum_return_vector <- append(cum_return_vector, new_cum_r)
  }
  return (cum_return_vector)
}
```

#create dataframe consisting of respective cum returns
```{r}
lasso_cum_return <- cum_return(data1, lasso_daily_returns, cum_lasso_returns_vector) #lasso regularised cum return
ridge_cum_return <- cum_return(data1, ridge_daily_returns, cum_ridge_returns_vector) #ridge regularised cum return
ew_cum_return <- cum_return(data1, ew_daily_returns, cum_ew_returns_vector) #equally weighted cum return
#create returns dataframe
returns_df <- data1 %>% 
  select(Dates) %>%
  mutate(Dates = ymd(Dates),
         Ridge_Cum_Return = ridge_cum_return,
         Lasso_Cum_Return = lasso_cum_return,
         EW_Cum_Return = ew_cum_return)
```

##plotting graph
```{r}
ggplot(returns_df, aes(x = Dates)) +
  geom_line(aes(y = Ridge_Cum_Return, color = "Ridge")) +
  geom_line(aes(y = Lasso_Cum_Return, color = "LASSO")) +
  geom_line(aes(y = EW_Cum_Return, color = "Equally-Weighted")) +
  scale_color_manual(name = "Legend", values = c("Ridge" = "blue", 
                                                 "LASSO" = "darkred", 
                                                 "Equally-Weighted" = "black")) +
  labs(title = "Cumulative Return", subtitle = "based on $10 initial investment", y = '', x = "Dates") +
  theme(plot.title = element_text(face="bold"),
        plot.subtitle = element_text(face = "italic"))
```









